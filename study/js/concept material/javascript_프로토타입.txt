============================================================
정의:
1. 프로토타입 객체를 참조하는 prototype 속성
2. 객체 멤버인 proto 속성이 참조하는 숨은 링크
============================================================




============================================================
멤버의 종류
생성자 멤버, 객체 멤버(프로토타입 멤버, 인스턴스 멤버)

생성자(constructor)함수
함수를 만들 때처럼 function을 쓰긴 하지만 함수와는 달리 대문자로 시작하게 만듭니다.
this는 생성자 함수 자신을 가리킵니다.

#1

function Person(name, gender) {
  this.name = name;
  this.gender = gender;
  this.sayHello = function() {
    alert(this.name + ' said "hello"');
  }
  this.... // 사람의 속성과 메소드를 더 정의할 수 있습니다.
}

var zero = new Person('Zero', 'm'); 	// Person {name: 'Zero', gender: 'm'}
zero.sayHello(); 	// 'Zero said "hello"'


#2

function Person(name, gender) {
  this.name = name;
  this.gender = gender;
}
Person.prototype.sayHello = function() {
  alert(this.name + ' said "hello"');
};

this.sayHello보다 prototype에 Person.prototype.sayHello로 넣는 게 더 효율적입니다.
prototype은 모든 객체가 공유하고 있어서 한 번만 만들어지지만,
this에 넣은 것은 객체 하나를 만들 때마다 메소드도 하나씩 만들어지기 때문에 불필요한 메모리 낭비가 발생합니다.

Person.prototype.constructor === Person;	//true
Person.prototype === (Person생성자로 만들어진 객체).__proto__;	  //true
(Person생성자로 만들어진 객체).__proto__.constructor === Person;	    //true
============================================================




============================================================
<함수와 객체의 내부 구조>
JavaScript에서는 함수를 정의하고, 파싱단계에 들어가면, 내부적으로 수행되는 작업이 있습니다.
생성자 함수 멤버로 prototype 속성이 있습니다. 이 속성은 다른 곳에 생성된 함수이름의 프로토타입 객체를 참조합니다.
프로토타입 객체의 멤버인 constructor 속성은 생성자 함수를 참조하는 내부구조를 가집니다.
============================================================




============================================================
1.

function Person(){}

속성이 하나도 없는 Person이라는 함수가 정의되고, 파싱단계에 들어가면,
Person 함수의 Prototype 속성은 프로토타입 객체를 참조합니다.
프로토타입 객체의 멤버인 constructor 속성은 Person 함수를 참조하는 구조를 가집니다.
여기서 알아야 하는 부분은 Person 함수의 prototype 속성이 참조하는 프로토타입 객체는
new라는 연산자와 Person 함수를 통해 생성된 모든 객체의 원형이 되는 객체라는겁니다.
생성된 모든 객체가 참조하는 프로토타입 객체 라는 것을 기억해야 합니다.
============================================================




===========================================================
2.

function Person(){}

var joon = new Person();
var jisoo = new Person();

JavaScript에서는 기본 데이터 타입인 boolean, number, string, 그리고 특별한 값인 null, undefined 빼고는 모두 객체입니다.
사용자가 정의한 함수도 객체이고, new라는 연산자를 통해 생성된 것도 객체입니다.
객체 안에는 __proto__ 속성이 있습니다.
이 속성은 객체가 만들어지기 위해 사용된 원형인 프로토타입 객체를 숨은 링크로 참조하는 역할을 합니다.
============================================================




============================================================
<프로토타입 객체>
함수를 정의하면 다른 곳에 생성되는 프로토타입 객체는 자신이 다른 객체의 원형이 되는 객체입니다.
모든 객체는 프로토타입 객체에 접근할 수 있습니다.
프로토타입 객체도 동적으로 런타임에 멤버를 추가할 수 있습니다.
같은 원형을 복사하여 생성된 모든 객체는 원형에 추가된 멤버를 사용할 수 있습니다.
=============================================================




=============================================================
3.

function Person(){}

var joon = new Person();
var jisoo = new Person();

Person.prototype.getType = function (){ 
    return "인간"; 
};

console.log(joon.getType());   // 인간
console.log(jisoo.getType());  // 인간

위 소스 6번째 라인은 함수 안의 prototype 속성을 이용하여 멤버를 추가하였습니다.
프로토타입 객체에 getType()이라는 함수를 추가하면 멤버를 추가하기 전에 생성된 객체에서도 추가된 멤버를 사용할 수 있습니다.
같은 프로토타입을 이용하여 생성된 joon과 jisoo 객체는 getType()을 사용할 수 있습니다.

함수 안의 prototype 속성
프로토타입 객체에 멤버를 추가, 수정, 삭제, 읽기를 할 수 있다.

객체 이름
프로토타입 객체의 맴버를 읽을 수만 있다.
=============================================================




=============================================================
4.

joon.getType = function (){ 
    return "사람"; 
};

console.log(joon.getType());   // 사람
console.log(jisoo.getType());  // 인간

jisoo.age = 25;

console.log(joon.age);   // undefined
console.log(jisoo.age);  // 25

위 소스 1번째 라인은 joon 객체를 이용하여 getType() 리턴 값을 사람으로 수정하였습니다.
그리고 joon과 jisoo에서 각각 getType()을 호출하면
joon 객체를 이용하여 호출한 결과는 사람으로 출력되고, jisoo로 호출한 결과는 인간이 출력됩니다.
생성된 객체를 이용하여 프로토타입 객체의 멤버를 수정하면 프로토타입 객체에 있는 멤버를 수정하는 것이 아니라
자신의 객체에 멤버를 추가하는 것입니다.
joon 객체를 사용하여 getType()을 호출하면 프로토타입 객체의 getType()을 호출한 것이 아닙니다.
joon 객체에 추가된 getType()을 호출한 것입니다.
프로토타입 객체의 멤버를 수정할 경우는 멤버 추가와 같이 함수의 prototype 속성을 이용하여 수정합니다.
=============================================================




=============================================================
5.

Person.prototype.getType = function (){
    return "사람"; 
};

console.log(jisoo.getType());  // 사람

위 소스를 보게 되면 함수의 prototype 속성을 이용하여 getType() 리턴 값을 사람으로 수정합니다.
그리고 jisoo 객체를 이용하여 호출한 결과 사람이 나옵니다.
=============================================================




=============================================================
결론을 내리면,
프로토타입 객체는 새로운 객체가 생성되기 위한 원형이 되는 객체입니다.
같은 원형으로 생성된 객체가 공통으로 참조하는 공간입니다.
프로토타입 객체의 멤버를 읽는 경우에는 객체 또는 함수의 prototype 속성을 통해 접근할 수 있습니다.
하지만 추가, 수정, 삭제는 함수의 prototype 속성을 통해 접근해야 합니다.
=============================================================




=============================================================
<프로토타입>
JavaScript에서 기본 데이터 타입을 제외한 모든 것이 객체입니다. 
객체는 원형인 프로토타입 객체를 이용하여 만듭니다
이때 만들어진 객체 안에 있는 __proto__속성에
자신을 만들어낸 원형을 의미하는 프로토타입 객체를 참조하는 숨겨진 링크가 있습니다.
이 숨겨진 링크를 프로토타입이라고 정의합니다.
=============================================================




=============================================================
6.

function Person(){}

var joon = new Person();

프로토타입을 크게 두 가지로 해석된다 했습니다.

1. joon 객체의 멤버인 __proto__ 속성에 있는 프로토타입 객체를 가리키는 숨은 링크를 프로토타입이라고 합니다. 
   객체 안의 __proto__속성은 자신을 만들어낸 원형인 프로토타입 객체를 참조하는 숨겨진 링크로써 프로토타입을 의미합니다.

2. 함수의 멤버인 prototype 속성은 프로토타입 객체를 참조하는 속성입니다.
   그리고 함수와 new 연산자가 만나 생성한 객체의 프로토타입 객체를 지정해주는 역할을 합니다.
=============================================================




==============================================================
JavaScript에서는 숨겨진 링크가 있어 프로토타입 객체 멤버에 접근할 수 있습니다.
그래서 이 숨겨진 프로토타입 링크를 사용자가 정의한 객체에 참조되도록 설정하면
코드의 재사용과 객체 지향적인 프로그래밍을 할 수 있습니다.
==============================================================