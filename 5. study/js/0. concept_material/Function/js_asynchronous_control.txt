
< 동기, 비동기 (synchronous, asynchronous) >
===============================================================================

[ 동기 (synchronous) ]
-----------------------------------------------------------------------------------------------------------
요청 처리가 완료 된 후 다음 요청을 처리 하는 방식으로,
이전 요청을 처리하는 시간이 다음 요청에 영향을 준다.
요청과 응답이 같은 시간대에 있다.
"일반적으로 작성한 코드는 보통 동기 방식으로 처리"된다.

ex)
function add() {...}
function minus() {...}
add();    // 이 코드는 동기적으로 실행됨
minus();    // 이 코드는 동기적으로 실행됨

setTimeout(add, 1000);    // 이 코드는 비동기적으로 실행됨
setTimeout(minus, 1000);    // 이 코드는 비동기적으로 실행됨
-----------------------------------------------------------------------------------------------------------


[ 비동기 (asynchronous) ]
-----------------------------------------------------------------------------------------------------------
하나의 요청 처리가 완료되기 전에 다음 요청을 처리 하는 방식.
( 즉, 요청하는 쪽과 처리하는 쪽이 구분되어있다. )
요청과 응답이 다른 시간대에 일어날 수 있다.


~ 비동기적 코드의 뜻과 대표적인 비동기적인 코드의종류 ~

웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고,
그에 대한 응답이 왔을 때 비로소 어떤 함수를 실행하도록 대기하는등
별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드다.
XMLHttpRequest(), addEventListener(), setTimeout() 등을 사용한 코드들.


~ 비동기적인 코드의 특징 ~

말 그대로 "비동기"라는 특징을 가진다.
비동기 작업은 성공 혹은 실패한다.
비동기 작업은 요청하는 쪽과 처리하는 쪽이 구분되어있다.


~ 비동기 처리 제어를 하는 이유 ~

"우리가 필요에 의해 사용"하는 XMLHttpRequest()를 이용한 서버에 대한 요청,
addEventListener()를 이용한 이벤트처리 대기, setTimeout()를 이용한 실행 보류 등이
비동기적인 작업이기 때문에 이 "작업들의 순서"를 우리가 원하는 대로 제어하기 위해서
비동기처리 제어를 해야 하고, 비동기 처리를 제어하는 Promise, async & await 등이 필요하다

( 예를 들면, 브라우저가 서버에 웹페이지에대한 정보를 요청하고 요청결과를 받고 그 결과를
화면에 표시해야 하지만, '별도의 요청' 관련코드는 비동기적인 코드이기 때문에
웹페이지에대한 정보를 요청하고 그 결과를 받기도 전에 화면표시를 해버리는 불상사가 일어난다.
이런 비동기 처리의 문제를 해결하기 위해 비동기 처리를 제어해야 한다는 것이다.)
-----------------------------------------------------------------------------------------------------------

===============================================================================








< 비동기 처리의 문제점>
===============================================================================

[ 비동기적인 코드의 문제점 ]
-----------------------------------------------------------------------------------------------------------
코드의 진행 "순서"를 제어할 수 없다는 점이 비동기적인 코드의 문제점이다.
-----------------------------------------------------------------------------------------------------------


[ 예시코드 - 1 ]
-----------------------------------------------------------------------------------------------------------
function asyncWork() {
    setTimeout(() => {
        console.log('첫번째');
    }, 3000 * Math.random());

    setTimeout(() => {
        console.log('두번째');
    }, 3000 * Math.random());

    setTimeout(() => {
        console.log('세번째');
    }, 3000 * Math.random());
}
asyncWork();
-----------------------------------------------------------------------------------------------------------


[ 예시코드 - 1 설명 ]
-----------------------------------------------------------------------------------------------------------
순서대로 나열된 setTimeout() 함수들이 각각 최대 3초의 random 시간 후
차례대로 동작할 것 같지만, 실제로 세 함수는 거의 동시에 시작한다고 볼 수 있습니다.

그 이유는 비동기 함수들도 위에서 아래로 순서대로 호출되는데,
비동기 함수들은 함수 호출이 일어나면 콜 스택이 아닌 Web API로 넘어가서 코드의 처리가 이루어지고,
처리가 끝난 비동기 함수들은 콜백 큐에 쌓이게 되고 콜 스택이 비었을 때 쌓인순서대로 콜 스택에 넘어가서 실행이됩니다.
이 때 콜 스택은 Web API에서 개별적으로 처리되는 비동기 코드의 존재를 인지하지 못합니다.
때문에, 먼저 호출된 함수의 결과를 받기도 전에 바로 다음 함수를 호출해 버립니다.
위의 이유들로 먼저 호출된 함수가 가장 먼저 완료가 될 것이라고 보장할 수 없게된다는걸 알 수 있을겁니다.
( 가장 먼저 처리가 끝나는 함수가 가장 먼저 실행이 되겠죠. )
그리고 같은 이유로 딜레이시간이 겹쳐져서 우리가 대략적으로 기대한만큼 딜레이가 안된다는 것을 알 수 있죠.

그러므로, 실제 예시코드 - 1 의 출력은
"실행 순서"대로 '첫번째', '두번째', '세번째' 가 아니라
"Random 순서"로 '첫번째', '두번째', '세번째' 가 출력됩니다.
-----------------------------------------------------------------------------------------------------------

===============================================================================










< 비동기 처리 제어 방법 (1) - Callback_funciton >
===============================================================================

[ 예시코드 - 2 ]
-----------------------------------------------------------------------------------------------------------
function asyncWork() {
    setTimeout(() => {
        console.log('첫번째');
        setTimeout(() => {
            console.log('두번째');
            setTimeout(() => {
                console.log('세번째');
            }, 3000 * Math.random());
        }, 3000 * Math.random());
    }, 3000 * Math.random());
}
asyncWork();
-----------------------------------------------------------------------------------------------------------


[ 예시코드 - 2 설명 ]
-----------------------------------------------------------------------------------------------------------
각각의 setTimeout() 함수는 먼저 실행될 setTimeout() 함수의 callback 함수안에서 호출되고 있습니다.
각 callback 함수 내에서는 위에서 아래의 순서로 console.log("순서 표시") 와
다음 setTimeout() 을 호출해주면서 순서 제어 문제를 해결했습니다.
그리고 딜레이시간도 겹치지 않고 따로 실행되었음을 알 수 있습니다.

그러므로, 예시코드 - 2 의 출력은
"실행 순서"로 '첫번째', '두번째', '세번째' 가 출력됩니다.
-----------------------------------------------------------------------------------------------------------


[ 이 방법의 문제점 ]
-----------------------------------------------------------------------------------------------------------
콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로
깊어지기 때문에 가독성이 떨어지고, 코드를 수정하기도 어렵다는 큰 단점이 있습니다.
그래서, 위 예시코드 - 2 와 같은 코드를 콜백지옥(callback hell) 이라고도 부릅니다.
-----------------------------------------------------------------------------------------------------------

===============================================================================









< 비동기 처리 제어 방법 (2) - Promise >
===============================================================================

 - 비동기에서 성공 혹은 실패로 완료된 결과 값을 받고 구분해서 메서드를 수행한다  - 

[ Promise 구문 ]
-----------------------------------------------------------------------------------------------------------
~ new Promise ( function( resolve, reject ) {...} ); ~

인수로 반드시 function 을 받아야 하고,
인수를 받지 않거나 함수이외의 값을 전달하면, Uncaught TypeError 가 발생한다.
-----------------------------------------------------------------------------------------------------------


[ then, catch 구문 ]
-----------------------------------------------------------------------------------------------------------
~ then(function(resolve한테 넘겨받은 결과 값) {...} ~

~ catch(function(reject한테 넘겨받은 결과 값) {...} ~
-----------------------------------------------------------------------------------------------------------


[ Promise의 상태(states) ]
-----------------------------------------------------------------------------------------------------------
Pending: 아직 결과 값이 반환되지 않은 진행 중인 상태 (대기)

Settled: 결과 값이 성공 혹은 실패로 반환된 상태
       - (1). Fulfilled: 성공
       - (2). Rejected: 실패
-----------------------------------------------------------------------------------------------------------


[ Pending (대기) ]
-----------------------------------------------------------------------------------------------------------
new Promise ( function( resolve, reject ) {...} ) 로 Promise 인스턴스 객체를 생성하고,
인수로 전달된 resolve 와 reject 중 하나라도 호출하지 않았으면 Pending 상태로 대기한다.
-----------------------------------------------------------------------------------------------------------


[ Fulfilled (성공) ]
-----------------------------------------------------------------------------------------------------------
new Promise ( function( resolve, reject ) { resolve(then에 넘겨줄 결과 값); } ) 와 같이
인수로 전달받은 resolve를 호출하면 Promise인스턴스 객체는 Fulfilled 상태가 된다. 
그리고 Fulfilled 상태가 되면 then() 메서드를 이용해서 resolve에게 결과 값을 받을 수 있다.
-----------------------------------------------------------------------------------------------------------


[ Rejected (실패) ]
-----------------------------------------------------------------------------------------------------------
new Promise ( function( resolve, reject ) { reject(catch에 넘겨줄 결과 값); } ) 와 같이
인수로 전달받은 reject를 호출하면 Promise인스턴스 객체는 Rejected 상태가 된다.
그리고 Rejected 상태가 되면 catch() 메서드를 이용해서 reject에게 결과 값을 받을 수 있다.
-----------------------------------------------------------------------------------------------------------


[ Promise의 에러 처리 방법 ]
-----------------------------------------------------------------------------------------------------------
(1). then()의 두 번째 인자로 에러를 처리하는 방법

new Promise ( function( resolve, reject ) { ... } ).then( handleSuccess, handleError );


(2). catch()를 이용하는 방법  ( 권장 )

new Promise ( function( resolve, reject ) { ... } ).then().catch();
-----------------------------------------------------------------------------------------------------------


[ ! 주의할 점 ! ]
-----------------------------------------------------------------------------------------------------------
(1)
Promise 인스턴스 객체의 콜백함수에서 resolve를 쓰면 then내부 코드를 reject를 쓰면 catch내부 코드를 실행

(2)
then메서드, catch메서드는 Promise 인스턴스 객체를 반환한다 그래서 연속적(chain)으로
then메서드, catch메서드를 사용할 수 있다. ( Promise chaining )

(3)
Promise 인스턴스 객체의 콜백함수 내부 에러, Promise 인스턴스 객체의 콜백함수의 인수인 reject함수 실행,
then메서드 내부 에러, catch메서드 내부 에러 등이 발생할 경우 밑에 연결돼있는
catch메서드중 가장 가까운 catch의 매개변수에 에러정보를 넘기고 내부 코드실행

(4)
에러처리를 한 catch메서드 이후에도 chaining이 가능하다
( 하지만 에러처리를 위해 사용된 catch메서드의 이전에 나온 메서드들은 실행이 되지않는다. )

(5)  - 밑의 자료 참고  - 
catch메서드를 이용한 에러 처리 과정 중 가장 마지막에 발생한 에러만 catch메서드에서 에러처리가 일어난다.
( catch 메서드의 매개변수에는 마지막으로 발생한 에러의 에러 정보가 담김 )
( "위에서 아래로 흘러간다"라고 생각하면 쉽다 )

(6)
에러처리를 할게 없어서 안 쓰인 catch메서드는 건너뛴다.
-----------------------------------------------------------------------------------------------------------


[ (5) 참고 자료 ]
-----------------------------------------------------------------------------------------------------------
첫 번째 에러발생
↓
첫 번째 에러를 catch메서드에서 에러처리중 catch메서드 내부에서 두 번째 에러발생
↓
밑에 있는 catch 메서드 중 가장 가까운 메서드에서 두 번째를 에러처리
↓
첫 번째 에러에대한 에러처리는 씹히고
↓
두 번째 에러에대한 에러처리가 작동한다.
-----------------------------------------------------------------------------------------------------------

===============================================================================










< 비동기 처리 제어 방법 (3) - Generator >
===============================================================================
 -   - 
===============================================================================










< 비동기 처리 제어 방법 (4) - async & await >
===============================================================================
 -   - 
===============================================================================


























































