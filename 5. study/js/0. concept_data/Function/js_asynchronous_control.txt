
< 동기, 비동기 (synchronous, asynchronous) >
===============================================================================

[ 동기 (synchronous) ]
-----------------------------------------------------------------------------------------------------------
요청 처리가 완료 된 후 다음 요청을 처리 하는 방식으로,
이전 요청을 처리하는 시간이 다음 요청에 영향을 준다.
요청과 응답이 같은 시간대에 있다.
"일반적으로 작성한 코드는 보통 동기 방식으로 처리"된다.

ex)
function add() {...}
function minus() {...}
add();    // 이 코드는 동기적으로 실행됨
minus();    // 이 코드는 동기적으로 실행됨

setTimeout(add, 1000);    // 이 코드는 비동기적으로 실행됨
setTimeout(minus, 1000);    // 이 코드는 비동기적으로 실행됨
-----------------------------------------------------------------------------------------------------------


[ 비동기 (asynchronous) ]
-----------------------------------------------------------------------------------------------------------
하나의 요청 처리가 완료되기 전에 다음 요청을 처리 하는 방식.
( 즉, 요청하는 쪽과 처리하는 쪽이 구분되어있다. )
요청과 응답이 다른 시간대에 일어날 수 있다.


~ 비동기적 코드의 뜻과 대표적인 비동기적인 코드의종류 ~

웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고,
그에 대한 응답이 왔을 때 비로소 어떤 함수를 실행하도록 대기하는등
별도의 요청, 실행 대기, 보류 등과 관련된 코드는 비동기적인 코드다.
XMLHttpRequest(), addEventListener(), setTimeout() 등을 사용한 코드들.


~ 비동기적인 코드의 특징 ~

말 그대로 "비동기"라는 특징을 가진다.
비동기 작업은 성공 혹은 실패한다.
비동기 작업은 요청하는 쪽과 처리하는 쪽이 구분되어있다.


~ 비동기 처리 제어를 하는 이유 ~

"우리가 필요에 의해 사용"하는 XMLHttpRequest()를 이용한 서버에 대한 요청,
addEventListener()를 이용한 이벤트처리 대기, setTimeout()를 이용한 실행 보류 등이
비동기적인 작업이기 때문에 이 "작업들의 순서"를 우리가 원하는 대로 제어하기 위해서
비동기처리 제어를 해야 하고, 비동기 처리를 제어하는 Promise, async & await 등이 필요하다

( 예를 들면, 브라우저가 서버에 웹페이지에대한 정보를 요청하고 요청결과를 받고 그 결과를
화면에 표시해야 하지만, '별도의 요청' 관련코드는 비동기적인 코드이기 때문에
웹페이지에대한 정보를 요청하고 그 결과를 받기도 전에 화면표시를 해버리는 불상사가 일어난다.
이런 비동기 처리의 문제를 해결하기 위해 비동기 처리를 제어해야 한다는 것이다.)
-----------------------------------------------------------------------------------------------------------

===============================================================================








< 비동기 처리의 문제점>
===============================================================================

[ 비동기적인 코드의 문제점 ]
-----------------------------------------------------------------------------------------------------------
코드의 진행 "순서"를 제어할 수 없다는 점이 비동기적인 코드의 문제점이다.
-----------------------------------------------------------------------------------------------------------


( 예시코드 - 1 )
-----------------------------------------------------------------------------------------------------------
function asyncWork() {
    setTimeout(() => {
        console.log('첫번째');
    }, 3000 * Math.random());

    setTimeout(() => {
        console.log('두번째');
    }, 3000 * Math.random());

    setTimeout(() => {
        console.log('세번째');
    }, 3000 * Math.random());
}
asyncWork();
-----------------------------------------------------------------------------------------------------------


[ 예시코드 - 1 설명 ]
-----------------------------------------------------------------------------------------------------------
순서대로 나열된 setTimeout() 함수들이 각각 최대 3초의 random 시간 후
차례대로 동작할 것 같지만, 실제로 세 함수는 거의 동시에 시작한다고 볼 수 있습니다.

그 이유는 비동기 함수들도 위에서 아래로 순서대로 호출되는데,
비동기 함수들은 함수 호출이 일어나면 콜 스택이 아닌 Web API로 넘어가서 코드의 처리가 이루어지고,
처리가 끝난 비동기 함수들은 콜백 큐에 쌓이게 되고 콜 스택이 비었을 때 쌓인순서대로 콜 스택에 넘어가서 실행이됩니다.
이 때 콜 스택은 Web API에서 개별적으로 처리되는 비동기 코드의 존재를 인지하지 못합니다.
때문에, 먼저 호출된 함수의 결과를 받기도 전에 바로 다음 함수를 호출해 버립니다.
위의 이유들로 먼저 호출된 함수가 가장 먼저 완료가 될 것이라고 보장할 수 없게된다는걸 알 수 있을겁니다.
( 가장 먼저 처리가 끝나는 함수가 가장 먼저 실행이 되겠죠. )
그리고 같은 이유로 딜레이시간이 겹쳐져서 우리가 대략적으로 기대한만큼 딜레이가 안된다는 것을 알 수 있죠.

그러므로, 실제 예시코드 - 1 의 출력은
"실행 순서"대로 '첫번째', '두번째', '세번째' 가 아니라
"Random 순서"로 '첫번째', '두번째', '세번째' 가 출력됩니다.
-----------------------------------------------------------------------------------------------------------

===============================================================================










< 비동기 처리 제어 방법 (1) - Callback_funciton >
===============================================================================

[ 예시코드 - 2 ]
-----------------------------------------------------------------------------------------------------------
function asyncWork() {
    setTimeout(() => {
        console.log('첫번째');
        setTimeout(() => {
            console.log('두번째');
            setTimeout(() => {
                console.log('세번째');
            }, 3000 * Math.random());
        }, 3000 * Math.random());
    }, 3000 * Math.random());
}
asyncWork();
-----------------------------------------------------------------------------------------------------------


[ 예시코드 - 2 설명 ]
-----------------------------------------------------------------------------------------------------------
각각의 setTimeout() 함수는 먼저 실행될 setTimeout() 함수의 callback 함수안에서 호출되고 있습니다.
각 callback 함수 내에서는 위에서 아래의 순서로 console.log("순서 표시") 와
다음 setTimeout() 을 호출해주면서 순서 제어 문제를 해결했습니다.
그리고 딜레이시간도 겹치지 않고 따로 실행되었음을 알 수 있습니다.

그러므로, 예시코드 - 2 의 출력은
"실행 순서"로 '첫번째', '두번째', '세번째' 가 출력됩니다.
-----------------------------------------------------------------------------------------------------------


[ 이 방법의 문제점 ]
-----------------------------------------------------------------------------------------------------------
콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로
깊어지기 때문에 가독성이 떨어지고, 코드를 수정하기도 어렵다는 큰 단점이 있습니다.
그래서, 위 예시코드 - 2 와 같은 코드를 콜백지옥(callback hell) 이라고도 부릅니다.
-----------------------------------------------------------------------------------------------------------

===============================================================================









< 비동기 처리 제어 방법 (2) - Promise >
===============================================================================

 - 비동기에서 성공 혹은 실패로 완료된 결과 값을 받고 구분해서 메서드를 수행한다  - 

[ Promise 구문 ]
-----------------------------------------------------------------------------------------------------------
~ new Promise ( function( resolve, reject ) {...} ); ~

인수로 반드시 function 을 받아야 하고,
인수를 받지 않거나 함수이외의 값을 전달하면, Uncaught TypeError 가 발생한다.
-----------------------------------------------------------------------------------------------------------


( 예시 코드 4-1 )
-----------------------------------------------------------------------------------------------------------
const promise = new Promise(function (res, rej) {
    setTimeout(function () {     // 비동기로 진행되는 코드
        res(111);
    }, 1000);
});


// 화살표 함수로 작성해도 동일하다.

cosnt promise = new Promise((res, rej) => {
    setTimeout(() => {
        res(111);
    }, 1000);
});

-----------------------------------------------------------------------------------------------------------


[ then, catch 구문 ]
-----------------------------------------------------------------------------------------------------------
~ then(function(resolve한테 넘겨받은 결과 값) {...} ~

~ catch(function(reject한테 넘겨받은 결과 값) {...} ~
-----------------------------------------------------------------------------------------------------------


[ Promise의 상태(states) ]
-----------------------------------------------------------------------------------------------------------
Pending: 아직 결과 값이 반환되지 않은 진행 중인 상태 (대기)

Settled: 결과 값이 성공 혹은 실패로 반환된 상태
       - (1). Fulfilled: 성공
       - (2). Rejected: 실패
-----------------------------------------------------------------------------------------------------------


[ Pending (대기) ]
-----------------------------------------------------------------------------------------------------------
new Promise ( function( resolve, reject ) {...} ) 로 Promise 인스턴스 객체를 생성하고,
인수로 전달된 resolve 와 reject 중 하나라도 호출하지 않았으면 Pending 상태로 대기한다.
-----------------------------------------------------------------------------------------------------------


[ Fulfilled (성공) ]
-----------------------------------------------------------------------------------------------------------
new Promise ( function( resolve, reject ) { resolve(then에 넘겨줄 결과 값); } ) 와 같이
인수로 전달받은 resolve를 호출하면 Promise인스턴스 객체는 Fulfilled 상태가 된다. 
그리고 Fulfilled 상태가 되면 then() 메서드를 이용해서 resolve에게 결과 값을 받을 수 있다.
-----------------------------------------------------------------------------------------------------------


[ Rejected (실패) ]
-----------------------------------------------------------------------------------------------------------
new Promise ( function( resolve, reject ) { reject(catch에 넘겨줄 결과 값); } ) 와 같이
인수로 전달받은 reject를 호출하면 Promise인스턴스 객체는 Rejected 상태가 된다.
그리고 Rejected 상태가 되면 catch() 메서드를 이용해서 reject에게 결과 값을 받을 수 있다.
-----------------------------------------------------------------------------------------------------------


[ Promise의 에러 처리 방법 ]
-----------------------------------------------------------------------------------------------------------
(1). then()의 두 번째 인자로 에러를 처리하는 방법

new Promise ( function( resolve, reject ) { ... } ).then( handleSuccess, handleError );


(2). catch()를 이용하는 방법  ( 권장 )

new Promise ( function( resolve, reject ) { ... } ).then().catch();
-----------------------------------------------------------------------------------------------------------


[ ! 주의할 점 ! ]
-----------------------------------------------------------------------------------------------------------
(1)
Promise 인스턴스 객체의 콜백함수에서 resolve를 쓰면 then내부 코드를 reject를 쓰면 catch내부 코드를 실행

(2)
then메서드, catch메서드는 Promise 인스턴스 객체를 반환한다 그래서 연속적(chain)으로
then메서드, catch메서드를 사용할 수 있다. ( Promise chaining )

(3)
Promise 인스턴스 객체의 콜백함수 내부 에러, Promise 인스턴스 객체의 콜백함수의 인수인 reject함수 실행,
then메서드 내부 에러, catch메서드 내부 에러 등이 발생할 경우 밑에 연결돼있는
catch메서드중 가장 가까운 catch의 매개변수에 에러정보를 넘기고 내부 코드실행

(4)
에러처리를 한 catch메서드 이후에도 chaining이 가능하다
( 하지만 에러처리를 위해 사용된 catch메서드의 이전에 나온 메서드들은 실행이 되지않는다. )

(5)  + 밑의 참고자료 참조  + 
catch메서드를 이용한 에러 처리 과정 중 가장 마지막에 발생한 에러만 catch메서드에서 에러처리가 일어난다.
( catch 메서드의 매개변수에는 마지막으로 발생한 에러의 에러 정보가 담김 )
( "위에서 아래로 흘러간다"라고 생각하면 쉽다 )

(6)
에러처리를 할게 없어서 안 쓰인 catch메서드는 건너뛴다.
-----------------------------------------------------------------------------------------------------------


[ (5) 참고자료 ]
-----------------------------------------------------------------------------------------------------------
첫 번째 에러발생
↓
첫 번째 에러를 catch메서드에서 에러처리중 catch메서드 내부에서 두 번째 에러발생
↓
밑에 있는 catch 메서드 중 가장 가까운 메서드에서 두 번째를 에러처리
↓
첫 번째 에러에대한 에러처리는 씹히고
↓
두 번째 에러에대한 에러처리가 작동한다.
-----------------------------------------------------------------------------------------------------------


( 예시 코드 4-2 )
-----------------------------------------------------------------------------------------------------------
new Promise((res, rej) => {
        console.log('Initial');

        res();
    })
    .then(() => {
        throw new Error('Something failed');

        console.log('Do this');    // error 발생으로 실행되지 않는다.
    })
    .catch(err => {
        console.log(err);    // throw new Error의 인자 값이 넘어온다. 
    })
    .then(() => {
        console.log('Do this, whatever happened before');    // catch 구문 이후 chaining
    });

// 출력값
// Initial
// Something failed  (ERROR)
// Do this, whatever happened before (catch 메소드 이후 then 메소드 실행)
-----------------------------------------------------------------------------------------------------------

===============================================================================










< 비동기 처리 제어 방법 (3) - Generator >
===============================================================================

[ Generator 구문 ]
-----------------------------------------------------------------------------------------------------------
function* 함수명() {
  yield 값;
}
-----------------------------------------------------------------------------------------------------------


[ 특징 ]  ( 예시 코드 3-1 참조 )
-----------------------------------------------------------------------------------------------------------
제너레이터 함수를 호출하면 제너레이터 함수의 코드 블록이 실행되는 것이 아니라
제너레이터 객체를 반환하는데, 제너레이터 함수가 생성한 제너레이터 객체의 next 메서드를 호출하면
제너레이터 함수 안의 처음 만나는 yield 문까지 실행되고 일시 중단된다.
다시 next 메서드를 호출하면 중단된 위치에서 실행을 시작하고
다음 만나는 yield 문까지 실행되고 또 다시 일시 중단된다.
-----------------------------------------------------------------------------------------------------------


( 예시 코드 3-1 )
-----------------------------------------------------------------------------------------------------------
function* counter() {
    console.log('Point 1');
    yield 1;     // 첫번째 next 메서드 호출 시 여기까지 실행된다.
    console.log('Point 2');
    yield 2;     // 두번째 next 메서드 호출 시 여기까지 실행된다.
    console.log('Point 3');
    yield 3;     // 세번째 next 메서드 호출 시 여기까지 실행된다.
    console.log('Point 4');     // 네번째 next 메서드 호출 시 여기까지 실행된다.
}


const generatorObj = counter();

console.log(generatorObj.next());
// 첫번째 next 메서드 호출: 첫번째 yield 문까지 실행되고 일시 중단된다.
// Point 1
// {value: 1, done: false}


console.log(generatorObj.next());
// 두번째 next 메서드 호출: 두번째 yield 문까지 실행되고 일시 중단된다.
// Point 2
// {value: 2, done: false}


console.log(generatorObj.next());
// 세번째 next 메서드 호출: 세번째 yield 문까지 실행되고 일시 중단된다.
// Point 3
// {value: 3, done: false}


console.log(generatorObj.next());
// 네번째 next 메서드 호출: 제너레이터 함수 내의 모든 yield 문이 실행되면 done 프로퍼티 값은 true가 된다.
// Point 4
// {value: undefined, done: true}
-----------------------------------------------------------------------------------------------------------
===============================================================================










< 비동기 처리 제어 방법 (4) - async & await >
===============================================================================

[ async & await 구문 ]
-----------------------------------------------------------------------------------------------------------
async function 함수명() {
  await 비동기_처리_메서드_명();
}
-----------------------------------------------------------------------------------------------------------


[ 사용방법 ]  ( 예시 코드 4-1 참조 )
-----------------------------------------------------------------------------------------------------------
함수의 앞에 async 라는 예약어를 붙이고, 함수의 내부 로직 중
" Promise 객체를 반환하는 비동기처리 코드 " 앞에 await를 붙인다.
-----------------------------------------------------------------------------------------------------------


( 예시 코드 4-1 )
-----------------------------------------------------------------------------------------------------------
function fetchItems() {
    return new Promise(function (resolve, reject) {
        var items = [1, 2, 3];
        resolve(items)
    });
}

async function logItems() {
    var resultItems = await fetchItems();
    console.log(resultItems);     // [1,2,3]
}
-----------------------------------------------------------------------------------------------------------


[ 특징 ] 
-----------------------------------------------------------------------------------------------------------
(1)
일반 함수엔 await을 사용할 수 없고 async 함수 안에서만 사용할 수 있다.

(2)
await는 최상위 레벨 코드에서 작동하지 않지만
익명 async 함수로 코드를 감싸면 최상위 레벨 코드에도 await를 사용할 수 있다.

(3)
메서드 이름 앞에 async를 추가하면 async 클래스 메서드를 선언할 수 있다.
async 메서드와 async 함수는 Promise를 반환하고 await를 사용할 수 있다는 점에서 동일하다.

(4)
async/await을 사용하면 await가 대기를 처리해주고, try catch 를 사용할 수 있다는 장점때문에
then/catch 메서드가 거의 필요하지 않습니다. 하지만 async함수 바깥의 최상위 레벨 코드에서는
await를 사용할 수 없기때문에 then/catch 메서드를 추가해 최종 결과나 처리되지 못한 에러를 다룹니다.
-----------------------------------------------------------------------------------------------------------


[ 에러처리 ] ( 예시 코드 4-2 참조)
-----------------------------------------------------------------------------------------------------------
async & await 에서는 try catch 를 사용해서 에러를 처리합니다.
try catch 를 사용하면 네트워크 통신 오류뿐만 아니라
간단한 타입 오류 등의 일반적인 오류까지도 잡아낼 수 있습니다.
발견된 에러는 error 객체에 담기기 때문에 에러의 유형에 맞게 에러 코드를 처리하면된다.
-----------------------------------------------------------------------------------------------------------


( 예시 코드 4-2 )
-----------------------------------------------------------------------------------------------------------
async function logTodoTitle() {
    try {
        var user = await fetchUser();
        if (user.id === 1) {
            var todo = await fetchTodo();
            console.log(todo.title);     // delectus aut autem
        }
    } catch (error) {
        console.log(error);
    }
}
-----------------------------------------------------------------------------------------------------------


( 예시 코드 4-3 )
-----------------------------------------------------------------------------------------------------------
function promise() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject('이런 error가 떴네요;;');
        }, 2000);
    });
}

async function asyncCall() {
    try {
        console.log(1);
        const result = await promise();     // Promise가 settled될 때까지 기다린 후 결과 값 할당.
        console.log(result);
        console.log(2);
    } catch (err) {
        console.error(err);     // error 발생 시 catch 블락에서 잡히도록 handling
    }
}

asyncCall();

// 출력 값
// 1   (asyncCall 호출)
// 이런 error가 떴네요;;   ( reject 함수 호출로 catch에서 handling )
-----------------------------------------------------------------------------------------------------------


( 예시 코드 4-4 )  ( 실전 사용 예제 )
-----------------------------------------------------------------------------------------------------------
function fetchUser() {
    var url = 'https://jsonplaceholder.typicode.com/users/1'
    return fetch(url).then(function (response) {
        return response.json();
    });
}

function fetchTodo() {
    var url = 'https://jsonplaceholder.typicode.com/todos/1';
    return fetch(url).then(function (response) {
        return response.json();
    });
}



async function logTodoTitle() {
        var user = await fetchUser();
        if (user.id === 1) {
            var todo = await fetchTodo();
            console.log(todo.title);     // delectus aut autem
        }

-----------------------------------------------------------------------------------------------------------

===============================================================================
































[출처] : https://velog.io/@yejinh/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0

[출처] : https://programmingsummaries.tistory.com/325

[출처] : https://joshua1988.github.io/web-development/javascript/promise-for-beginners/

[출처] : https://velog.io/@jason_sj/JS-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%B2%98%EB%A6%AC%EC%97%90-%EC%83%88%EB%A1%AD%EA%B2%8C-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0

[출처] : https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=scw0531&logNo=221143544613

[출처] : https://joshua1988.github.io/web-development/javascript/js-async-await/